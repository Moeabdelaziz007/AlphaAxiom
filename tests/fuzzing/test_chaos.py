import json
import pytest
from hypothesis import given, strategies as st
from pydantic import ValidationError
from webhook_listener import TradingSignal, validate_passphrase, get_webhook_secret

# Strategies for chaos testing
valid_exchanges = st.sampled_from(["BYBIT", "MT5", "BINANCE"])
valid_actions = st.sampled_from(["BUY", "SELL"])
valid_symbols = st.sampled_from(["BTCUSDT", "ETHUSDT", "XAUUSD"])

@st.composite
def trading_signal_strategy(draw):
    return {
        "passphrase": draw(st.text()),
        "exchange": draw(valid_exchanges),
        "symbol": draw(valid_symbols),
        "action": draw(valid_actions),
        "volume": draw(st.floats(min_value=0.0001, max_value=1000.0)),
        "leverage": draw(st.integers(min_value=1, max_value=100)),
        "stop_loss": draw(st.one_of(st.none(), st.floats(min_value=0.1, max_value=100000.0))),
        "take_profit": draw(st.one_of(st.none(), st.floats(min_value=0.1, max_value=100000.0))),
    }

@given(signal_data=trading_signal_strategy())
def test_signal_model_validation_valid(signal_data):
    """Fuzz test: Should accept valid structures generated by strategy"""
    try:
        TradingSignal(**signal_data)
    except ValidationError:
        # Should not happen if strategy aligns with constraints
        pass

@given(volume=st.floats(max_value=0.0))
def test_signal_model_reject_invalid_volume(volume):
    """Fuzz test: Should reject 0 or negative volume"""
    data = {
        "passphrase": "secret",
        "exchange": "BYBIT",
        "symbol": "BTC",
        "action": "BUY",
        "volume": volume,
        "leverage": 1
    }
    with pytest.raises(ValidationError):
        TradingSignal(**data)

@given(leverage=st.integers(min_value=101))
def test_signal_model_reject_high_leverage(leverage):
    """Fuzz test: Should reject leverage > 100"""
    data = {
        "passphrase": "secret",
        "exchange": "BYBIT",
        "symbol": "BTC",
        "action": "BUY",
        "volume": 1.0,
        "leverage": leverage
    }
    with pytest.raises(ValidationError):
        TradingSignal(**data)

@given(garbage=st.text())
def test_passphrase_security(garbage):
    """Fuzz test: Passphrase validation should fail for random text"""
    # Assuming the secret is NOT the garbage (highly likely)
    # We must ensure we don't accidentally generate the real secret if it's "axiom_default_secret_change_me"

    current_secret = get_webhook_secret()
    if garbage == current_secret:
        assert validate_passphrase(garbage) is True
    else:
        assert validate_passphrase(garbage) is False

@given(
    price=st.floats(allow_nan=True, allow_infinity=True)
)
def test_extreme_prices_in_model(price):
    """Fuzz test: Handle NaNs or Infs in prices safely (Pydantic usually rejects or handles)"""
    data = {
        "passphrase": "secret",
        "exchange": "BYBIT",
        "symbol": "BTC",
        "action": "BUY",
        "volume": 1.0,
        "leverage": 1,
        "stop_loss": price
    }
    # We expect ValidationError for NaN/Inf usually, or it accepts it.
    # We just want to make sure it doesn't CRASH the interpreter or hang.
    try:
        TradingSignal(**data)
    except ValidationError:
        pass
    except ValueError:
        pass
